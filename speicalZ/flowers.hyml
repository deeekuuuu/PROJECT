<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Flower Garden</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fff5e6;
    }
    
    #c {
      display: block;
      cursor: crosshair;
      touch-action: none;
    }
    
    .controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .btn {
      padding: 10px 20px;
      background: rgba(220, 70, 90, 0.1);
      border: 2px solid #dc465a;
      color: #dc465a;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }
    
    .btn:hover {
      background: rgba(220, 70, 90, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(220, 70, 90, 0.3);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .instructions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      background: rgba(255, 245, 230, 0.9);
      border: 2px solid #dc465a;
      color: #dc465a;
      border-radius: 12px;
      font-size: 14px;
      text-align: center;
      backdrop-filter: blur(10px);
      z-index: 10;
      max-width: 90%;
    }
    
    @media (max-width: 600px) {
      .controls {
        top: 10px;
        left: 10px;
        gap: 8px;
      }
      
      .btn {
        padding: 8px 16px;
        font-size: 12px;
      }
      
      .instructions {
        bottom: 10px;
        padding: 10px 20px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  
  <div class="controls">
    <button class="btn" onclick="clearGarden()">Clear Garden</button>
    <button class="btn" onclick="toggleInstructions()">Toggle Help</button>
  </div>
  
  <div class="instructions" id="instructions">
    ðŸŒ¸ Draw on the canvas to grow beautiful flowers! Different drag lengths create different sized plants. ðŸŒ¸
  </div>

  <script>
/**
 * Interactive Flower Garden Canvas
 * Draw to create beautiful procedural flowers
 */

class FlowerGarden {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext("2d", { alpha: false });
    
    // State
    this.plants = [];
    this.drawing = false;
    this.currentPath = [];
    this.wind = 0;
    this.animationId = null;
    
    // Configuration
    this.config = {
      types: ["rose"], // Rose only
      minPathLength: 4,
      maxSize: 120,
      sizeMultiplier: 4,
      growthSpeed: 1.4,
      flowerGrowthSpeed: 0.3,
      branchProbability: 0, // No branches, single flower only
      branchSpread: 0.35,
      fadeAlpha: 1.0, // Solid background, no fade trail
      windSpeed: 0.01
    };
    
    this.init();
  }
  
  init() {
    this.resize();
    this.setupEventListeners();
    this.animate();
  }
  
  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }
  
  setupEventListeners() {
    // Resize handler
    window.addEventListener("resize", () => this.resize());
    
    // Touch events
    this.canvas.addEventListener("touchstart", (e) => this.handleStart(e), { passive: false });
    this.canvas.addEventListener("touchmove", (e) => this.handleMove(e), { passive: false });
    this.canvas.addEventListener("touchend", () => this.handleEnd());
    
    // Mouse events
    this.canvas.addEventListener("mousedown", (e) => this.handleStart(e));
    this.canvas.addEventListener("mousemove", (e) => this.handleMove(e));
    this.canvas.addEventListener("mouseup", () => this.handleEnd());
    this.canvas.addEventListener("mouseleave", () => this.handleEnd());
  }
  
  getPosition(e) {
    if (e.touches && e.touches.length > 0) {
      return {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
    }
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  
  handleStart(e) {
    e.preventDefault();
    this.drawing = true;
    this.currentPath = [this.getPosition(e)];
  }
  
  handleMove(e) {
    if (!this.drawing) return;
    e.preventDefault();
    this.currentPath.push(this.getPosition(e));
  }
  
  handleEnd() {
    if (!this.drawing) return;
    this.drawing = false;
    
    if (this.currentPath.length > this.config.minPathLength) {
      this.createPlant();
    }
    
    this.currentPath = [];
  }
  
  createPlant() {
    const type = this.config.types[Math.floor(Math.random() * this.config.types.length)];
    const firstPoint = this.currentPath[0];
    const size = Math.min(
      this.config.maxSize,
      this.currentPath.length * this.config.sizeMultiplier
    );
    
    const plant = new Branch(
      firstPoint.x,
      firstPoint.y,
      type,
      this.config
    );
    plant.target = size;
    
    this.plants.push(plant);
  }
  
  drawBackground() {
    this.ctx.fillStyle = `#fff5e6`; // Warm peachy cream background
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  drawCurrentPath() {
    if (this.currentPath.length < 2) return;
    
    this.ctx.strokeStyle = "#dc465a"; // Rose red color
    this.ctx.lineWidth = 2;
    this.ctx.lineCap = "round";
    this.ctx.lineJoin = "round";
    
    this.ctx.beginPath();
    this.ctx.moveTo(this.currentPath[0].x, this.currentPath[0].y);
    
    for (let i = 1; i < this.currentPath.length; i++) {
      this.ctx.lineTo(this.currentPath[i].x, this.currentPath[i].y);
    }
    
    this.ctx.stroke();
  }
  
  update() {
    this.wind += this.config.windSpeed;
    this.plants.forEach(plant => plant.grow());
  }
  
  render() {
    this.drawBackground();
    this.plants.forEach(plant => plant.draw(this.ctx));
    this.drawCurrentPath();
  }
  
  animate() {
    this.update();
    this.render();
    this.animationId = requestAnimationFrame(() => this.animate());
  }
  
  clear() {
    this.plants = [];
    this.ctx.fillStyle = "#fff5e6"; // Warm peachy cream
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}


class Branch {
  constructor(x, y, type, config, angle = -Math.PI / 2) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.config = config;
    
    this.angle = angle; // Always straight up by default
    this.length = 0;
    this.target = 80;
    this.width = 3.5;
    this.flowerSize = 0;
    
    this.children = [];
    this.done = false;
  }
  
  grow() {
    // Grow the branch
    if (this.length < this.target) {
      this.length += this.config.growthSpeed;
    } else if (!this.done) {
      this.done = true;
      this.createChildren();
    }
    
    // Grow children
    this.children.forEach(child => child.grow());
  }
  
  createChildren() {
    if (Math.random() < this.config.branchProbability) {
      const spread = this.config.branchSpread;
      
      // Left branch
      const leftBranch = new Branch(
        this.getEndX(),
        this.getEndY(),
        this.type,
        this.config
      );
      leftBranch.angle = this.angle - spread;
      leftBranch.width = this.width * 0.7;
      
      // Right branch
      const rightBranch = new Branch(
        this.getEndX(),
        this.getEndY(),
        this.type,
        this.config
      );
      rightBranch.angle = this.angle + spread;
      rightBranch.width = this.width * 0.7;
      
      this.children.push(leftBranch, rightBranch);
    }
  }
  
  getEndX() {
    return this.x + Math.cos(this.angle) * this.length;
  }
  
  getEndY() {
    return this.y + Math.sin(this.angle) * this.length;
  }
  
  draw(ctx) {
    // Draw stem
    ctx.strokeStyle = "#4f7c5c";
    ctx.lineWidth = this.width;
    ctx.lineCap = "round";
    
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.getEndX(), this.getEndY());
    ctx.stroke();
    
    // Draw flower at branch tips
    if (this.done && this.children.length === 0) {
      if (this.flowerSize < 16) {
        this.flowerSize += this.config.flowerGrowthSpeed;
      }
      
      FlowerRenderer.draw(
        ctx,
        this.getEndX(),
        this.getEndY(),
        this.flowerSize,
        this.type
      );
    }
    
    // Draw children
    this.children.forEach(child => child.draw(ctx));
  }
}


class FlowerRenderer {
  static draw(ctx, x, y, size, type) {
    if (size < 1) return;
    
    ctx.save();
    ctx.translate(x, y);
    
    switch (type) {
      case "rose":
        this.drawRose(ctx, size);
        break;
      case "tulip":
        this.drawTulip(ctx, size);
        break;
      case "daisy":
        this.drawDaisy(ctx, size);
        break;
      case "lotus":
        this.drawLotus(ctx, size);
        break;
      case "wild":
        this.drawWild(ctx, size);
        break;
    }
    
    ctx.restore();
  }
  
  static drawRose(ctx, size) {
    ctx.fillStyle = "rgba(220, 70, 90, 0.95)";
    
    for (let i = 0; i < 18; i++) {
      ctx.rotate(0.35);
      ctx.beginPath();
      ctx.ellipse(0, -size / 2, size / 3, size, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  static drawTulip(ctx, size) {
    ctx.fillStyle = "rgba(240, 90, 120, 0.95)";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.bezierCurveTo(-size, -size, -size / 2, -size * 2, 0, -size * 2);
    ctx.bezierCurveTo(size / 2, -size * 2, size, -size, 0, 0);
    ctx.fill();
  }
  
  static drawDaisy(ctx, size) {
    // Petals
    ctx.fillStyle = "white";
    for (let i = 0; i < 14; i++) {
      ctx.rotate(Math.PI * 2 / 14);
      ctx.beginPath();
      ctx.ellipse(0, -size, size / 4, size, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Center
    ctx.fillStyle = "gold";
    ctx.beginPath();
    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  static drawLotus(ctx, size) {
    ctx.fillStyle = "rgba(255, 180, 210, 0.95)";
    
    for (let i = 0; i < 12; i++) {
      ctx.rotate(Math.PI * 2 / 12);
      ctx.beginPath();
      ctx.ellipse(0, -size, size / 2, size * 1.3, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  static drawWild(ctx, size) {
    for (let i = 0; i < 10; i++) {
      ctx.rotate(Math.PI * 2 / 10);
      ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 70%)`;
      ctx.beginPath();
      ctx.ellipse(0, -size, size / 3, size, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}


// Initialize the garden when DOM is ready
let garden;

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => {
    garden = new FlowerGarden("c");
  });
} else {
  garden = new FlowerGarden("c");
}

// Global functions for controls
window.clearGarden = () => {
  if (garden) {
    garden.clear();
  }
};

window.toggleInstructions = () => {
  const instructions = document.getElementById('instructions');
  if (instructions.style.display === 'none') {
    instructions.style.display = 'block';
  } else {
    instructions.style.display = 'none';
  }
};
  </script>
</body>
</html>
